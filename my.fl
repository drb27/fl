// Predicate for testing for the empty list
empty=>(l) -> l.size().eq(0)

// Reverse a list
reverse=>(l) -> empty(l)? () : reverse(l.tail())::l.head()

// Reversed map
rmap=>(f,l) -> empty(l)? () : rmap(f,l.tail())::f(l.head())

// Normal map
map=>(f,l)->reverse(rmap(f,l))

// Build a list
range=>(b,e) -> b.eq(e) ? (e) : range(b,e.dec())::e

// Reverse-filter a list
rfilter=>(p,l)-> empty(l)? () : p(l.head())? rfilter(p,l.tail())::l.head() : rfilter(p,l.tail())

// Normal-filter a list
filter=>(p,l)->reverse(rfilter(p,l))

// Accumulate a list
accumulate=>(a,f,l) -> empty(l)? a : accumulate(f(a,l.head()),f,l.tail())
sum=>accumulate(0,(a,b)->a+b)

// Repeat an element in a list
rep=>(e,n)-> n.eq(0)? () : rep(e,n.dec())::e
repg=>(g,n) -> n.eq(0)? () : repg(g,n.dec())::g()

btoi=>(a)-> a? 1:0

or=>(a,b)-> btoi(a).add(btoi(b)).gt(0)
and=>(a,b)-> btoi(a).add(btoi(b)).eq(2)

true.class().addmethod( (a,b)->and(a,b), "and" )
true.class().addmethod( (a,b)->or(a,b), "or" )
1.class().addmethod( (x)->x+1, "inc" )

in_range=>(t,a,b)-> and(t.gt(a.dec()),t.gt(b).not())

eq=>(a,b)->a.eq(b)
containsp=>(l,v,t)-> empty(l)? false : t(l.head(),v)? true : containsp(l.tail(),v,t)
contains=>(l,v)->containsp(l,v,eq)

exceeds=>(l,v)->containsp(l,v,(x,y)->x.gt(y))

is_odd=>(x) -> x.eq(0) ? false : is_even(x.dec())
is_even=>(x) -> x.eq(0)? true : is_odd(x.dec())

countif=>(p,l)->filter(p,l).size()
countifnot=>(p,l)->countif((x)->p(x).not(),l)

merge=>(la,lb)-> empty(lb)? la : merge(la::lb.head(),lb.tail())

object=>null.class().base()
car=>object.derive("car")
car.addattr("wheels",4)

card=>object.derive("card")
card.addattr("value",0)
card.addattr("suit",0)

suit=>(c)-> c.suit.eq(1)? "diamonds" : c.suit.eq(2)? "spades" : c.suit.eq(3)? "clubs" : "hearts"

thing=>object.derive("thing")
thing.addattr("store",null)
thing.addattr("itemlist",null)
thing.addmethod( (t)-> { t.store=>keystore.new(()); t.itemlist=>(1,2,3) } , ".ctor")

do=>(f,l) -> empty(l)? null : { f(l.head()); do(f,l.tail()); null }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// NODES

node=>object.derive("node")
node.addattr("lower",null)
node.addattr("higher",null)
node.addattr("value",null)
node.addattr("tag",null)

make_node=>(v,l,h,t)-> { n=> node.new(()); n.lower=>l; n.higher=>h; n.value=>v; n.tag=>t; n}
copy_node=>(o)-> { n=> node.new(()); n.lower=>o.lower; n.higher=>o.higher; n.value=>o.value; n.tag=>o.tag; n}

insert=>(n,v,t)-> n.value.eq(v)? { n.tag=>t ; null } : { v.lt(n.value)? {n.lower.eq(null)? n.lower=>make_node(v,null,null,t) : insert(n.lower,v,t) }  : { n.higher.eq(null)? n.higher=>make_node(v,null,null,t) : insert(n.higher,v,t) } }

find=>(n,v)-> n.eq(null)? null : n.value.eq(v)? n : v.lt(n.value)? find(n.lower,v) : find(n.higher,v)  

node.addmethod(insert,"insert")
node.addmethod(find,"find")

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// BASIC KEYSTORE

first=>(a)->a.head()
second=>(a)->a.tail().head()

keystore=>object.derive("keystore")
keystore.addattr("store",())
keystore.addmethod( (t) -> t.store.size(), "size")
keystore.addmethod( (t,k,v)-> t.has(k)? null : t.store.append((k,v)),"add")
keystore.addmethod( (t,v)-> containsp(t.store,v, (e,v)-> first(e).eq(v)), "has")
keystore.addmethod( (t,k)-> t.has(k)? second(filter((p)->first(p).eq(k),t.store).head()) : null,"lookup")

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// BETTER KEYSTORE

intmap=>object.derive("intmap")
intmap.addattr("store",null)
intmap.addmethod( (t,k,v)-> t.store.eq(null)? { t.store=>make_node(k,null,null,v) ; t } : { insert( t.store, k, v ) ; t } , "add")
intmap.addmethod( (t,k) -> t.store.find(k), "find" )